<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Github_project_management</title>
    <url>/2024/11/09/Github-project-management/</url>
    <content><![CDATA[<p>​	关于将项目上传到github并进行管理，以及一些在使用过程中可能遇到的问题和解决方法。</p>
<span id="more"></span>

<blockquote>
<p>Precondition:</p>
<ol>
<li>有一个github账号</li>
<li>下载安装Git</li>
</ol>
</blockquote>
<blockquote>
<p>github常用的两种连接方式：</p>
<p>https连接，如：<code>https://github.com/Roricallry/handwriting-numerals-recognition.git</code></p>
<p>ssh连接，如：<code>git@github.com:Roricallry/handwriting-numerals-recognition.git</code></p>
<p>https连接每次都需要密码，ssh连接可以做到无密码连接</p>
</blockquote>
<p>Git常用指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init //把这个目录变成Git可以管理的仓库</span><br><span class="line">　　git add README.md //文件添加到仓库</span><br><span class="line">　　git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 </span><br><span class="line">　　git commit -m &quot;first commit&quot; //把文件提交到仓库</span><br><span class="line">　　git remote add origin git@github.com:wangjiax9/practice.git //关联远程仓库</span><br><span class="line">　　git push -u origin master //把本地库的所有内容推送到远程库上</span><br><span class="line">　　</span><br><span class="line">Git复制指令(或者直接鼠标右键菜单栏选择)：</span><br><span class="line">复制：Ctrl+INSERT</span><br><span class="line">粘贴：Shift+INSERT</span><br></pre></td></tr></table></figure>

<h3 id="项目上传"><a href="#项目上传" class="headerlink" title="项目上传"></a>项目上传</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>可分为两步，第一步是搭建本地仓库，第二步是关联上传到github项目仓库。</p>
<h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>首先在本机项目文件夹下打开git-bash.exe</p>
<ol>
<li><p>执行指令： git init </p>
<p>将这个目录变为Git可以管理的仓库，初始化成功后你会发现项目里多了一个隐藏文件夹.git<img src="/images/24-1.png" alt="屏幕截图 2024-11-09 224813"></p>
</li>
<li><p>执行指令：git add . </p>
<p>后面的点是个通配符，把所有文件都添加到本地仓库，也可以跟单一文件名添加单一文件。<img src="/images/24-2.png" alt="屏幕截图 2024-11-09 225518"></p>
</li>
<li><p>执行指令：git commit -m “【注释】”</p>
<p>把所有文件都提交到本地仓库，双引号里的内容是本次提交的注释<img src="/images/24-3.png" alt="屏幕截图 2024-11-09 230904"></p>
</li>
</ol>
<h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><ol>
<li><p>在github上新建一个repository，名字随便取，随后复制ssh仓库地址<img src="/images/24-4.png" alt="屏幕截图 2024-11-09 230527"></p>
</li>
<li><p>在本地之前那个bash窗口，执行：git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a>:Roricallry&#x2F;handwriting-numerals-recognition.git<img src="/images/24-5.png" alt="屏幕截图 2024-11-09 231016"></p>
</li>
<li><p>执行：git push -u origin master</p>
<p>将本地仓库上传到GitHub对应项目仓库的master分支<img src="/images/24-6.png" alt="屏幕截图 2024-11-09 231210"></p>
</li>
</ol>
<p>至此，项目文件已上传到Github上，可在对应项目的对应分支进行查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master --rebase</span><br></pre></td></tr></table></figure>

<p><code>git pull origin master --rebase</code> 会拉取远程分支的更改并在本地更改的基础上应用它们，这样可以减少冲突。</p>
<h3 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h3><p>如果远程仓库的提交记录与本地记录不一致，会导致提交失败，此时需对本地仓库进行更新再重新修改上传(防止多人协作时版本不一)</p>
<p>如果是个人开发，不考虑其他人，后面直接加   –force   （会覆盖远程仓库的历史）<img src="/images/24-7.png" alt="7"></p>
<p>下面这个错误是因为本地分支的名称是 <code>master</code>，而不是 <code>main</code>。因此，Git无法找到一个名为 <code>main</code> 的分支来推送。<img src="/images/24-8.png" alt="8"></p>
<p>解决办法有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\# 重命名本地的 master 分支为 main </span><br><span class="line">git branch -m master main </span><br><span class="line"><span class="comment"># 推送 main 分支到远程 </span></span><br><span class="line">git push -u origin main </span><br><span class="line"><span class="comment"># 设置默认分支为 main </span></span><br><span class="line">git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main</span><br></pre></td></tr></table></figure>



<p>单个文件不能超过50mb，本地提交记录中如果有超过50mb的文件的话也是会上传失败，建议（重开）重新克隆一个项目文件夹</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2024-38816</title>
    <url>/2025/04/27/CVE-2024-38816/</url>
    <content><![CDATA[<h4 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><p><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-27-232615.png"></p>
<p>漏洞描述：</p>
<p>Spring框架是 Java 平台的一个开源的全栈应用程序框架和控制反转容器实现。2024年9月，Spring官方发布公告披露 CVE-2024-38816 Spring Framework 特定条件下目录遍历漏洞。当同时满足使用 RouterFunctions 和 FileSystemResource 来处理和提供静态文件时，攻击者可构造恶意请求遍历读取系统上的文件。</p>
<p>影响范围：<br>Spring Framework</p>
<ul>
<li>5.3.0 - 5.3.39</li>
<li>6.0.0 - 6.0.23</li>
<li>6.1.0 - 6.1.12</li>
<li>Older, unsupported versions are also affected</li>
</ul>
<p>环境搭建：</p>
<ul>
<li>java版本:jdk 17</li>
<li>服务器：netty</li>
<li>构建工具：Gradle<br>pring boot版本:3.0.13对应spring framework 6.0.15</li>
</ul>
<p>项目依赖：Spring Reactive Web（webflux）</p>
<p>漏洞代码：</p>
<p><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-162217.png"></p>
<h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p><a href="https://github.com/spring-projects/spring-framework/commit/d86bf8b2056429edf5494456cffcb2b243331c49#diff-25869a3e3b3d4960cb59b02235d71d192fdc4e02ef81530dd6a660802d4f8707">具体修复commit</a></p>
<p>漏洞代码是PathResourceLookupFunction类中。</p>
<p>在调用了RouterFunctions来处理路由时会来到PathResourceLookupFunction类的这个地方：<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-161545.png"><br>（this.pattern是RouterFunctions.resources(“&#x2F;static&#x2F;<strong>“, new FileSystemResource(“ C:&#x2F; app&#x2F; static &#x2F; “))中的”&#x2F;static&#x2F;</strong>“，检测路径中是否包含”&#x2F;static&#x2F;“,若包含，则将后面的”**”与”C:&#x2F;app&#x2F;static&#x2F;“进行拼接。)</p>
<p>代码首先对路径是否存在指定路径片段进行判断，然后在procrssPath中对路径进行简单处理：<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-164801.png"></p>
<p>去除路径开头的无效字符：忽略空格、控制字符等无效字符，找到第一个有效字符。</p>
<p>保留根路径：如果路径开头有斜杠 &#x2F;，则确保处理后的路径以 &#x2F; 开头。</p>
<p>快速返回有效路径：如果路径是根路径或有效路径已经以 &#x2F; 开头，直接返回，不做额外处理。</p>
<p>然后会判断路径是否存在”%”进行一次url解码，然后进入isInvalidPath函数：<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-164324.png"><br>我们需要的是返回false，看来能够返回的只有一个地方return path.contains(“..”) &amp;&amp; StringUtils.cleanPath(path).contains(“..&#x2F;“);，首先我们可以有..这种字符的存在，因为是&amp;符号连接的，所以终极目的就是StringUtils.cleanPath(path).contains(“..&#x2F;“)返回false，恰好cleanPath中存在漏洞可以绕过”..&#x2F;“的检测。</p>
<p>下面是cleanPath函数分析:</p>
<p><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-215223.png"></p>
<p>先将’\’转换为’&#x2F;’。<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-215407.png"></p>
<p>然后是将path以‘&#x2F;’进行分割成数组。<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-215723.png"></p>
<p>检测数组中是否存在’..’如果存在则将tops+1，但是当元素中不存在’.’或’..’时，就能用该元素去抵消一个’..’<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-220622.png"><br>最后就是将prefix(path中的首字符)和pathElements进行拼接返回，回到isInvalidPath函数判断返回值中是否存在’..&#x2F;’<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-221402.png"><br>回到apply函数，路径会经过createRelative函数处理，而该函数调用了OI函数，及使用操作系统的处理方法，如windows中的路径仅支持反斜杠，而斜杠会被当成一个正常字符。isReadable会判断路径是否存在并可读。<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-30-164634.png"><br>isResourceUbderLocation中会再次url解码判断存在，但是只要路径中不存在’%’就可以绕过该检测。</p>
<p>综上分析，像static&#x2F;/..&#x2F;**这样的路径在经过处理后会变成static&#x2F;..&#x2F;**。</p>
<p><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-30-165443.png"><br>但是在实际测试中，在进入apply函数之前，’\’就会被转换成’&#x2F;’。</p>
<p>因此，利用上apply函数里面的第一个url解码，payload可以构造为static&#x2F;%5c&#x2F;%5c&#x2F;..&#x2F;..&#x2F;**，%5c的数量与..&#x2F;对应，可以穿越到任何路径。</p>
<h4 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h4><p><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-29-171942.png"><br>上图为漏洞存在证明。</p>
<p>分析与评估漏洞影响：<br>-该漏洞能够导致系统任意文件的泄露，对数据保密性具有极高危害，配合其他漏洞，可能会造成更近一步危害。</p>
<p>漏洞修复：</p>
<ul>
<li>升级 Spring 版本</li>
<li>Spring Boot 3.x 用户：升级至 Spring Framework 6.1.13+8。</li>
<li>Spring Boot 2.x 用户：官方未提供免费修复版本，需迁移至 Spring Boot 3.x38。</li>
</ul>
<p>临时缓解措施</p>
<ul>
<li>启用 Spring Security 的 HTTP 防火墙。</li>
<li>避免显式使用 FileSystemResource，改用 ClassPathResource 限制资源路径。</li>
<li>使用主流服务器Tomcat，Jetty。</li>
</ul>
<p>下面是Tomcat服务器运行示例，返回值400<br><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2025-04-30-171552.png"></p>
]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>certificate</title>
    <url>/2024/12/15/certificate/</url>
    <content><![CDATA[<p>本文主要讲述关于数字证书的颁发过程，小型CA项目搭建</p>
<span id="more"></span>

<p><img src="/images/cert.png" alt="证书"></p>
<h4 id="创建公私钥"><a href="#创建公私钥" class="headerlink" title="创建公私钥"></a>创建公私钥</h4><p>为root_ca生成证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成root_ca私钥</span><br><span class="line">openssl genrsa -out root_ca_key.pem 2048</span><br><span class="line"># 生成自签名证书</span><br><span class="line">openssl req -x509 -new -nodes -key root_ca_key.pem -sha256 -days 3650 -out root_ca_cert.pem</span><br></pre></td></tr></table></figure>



<p>为中间ca生成证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 为中间ca创建私钥</span><br><span class="line">openssl genrsa -out intermediate_ca_key.pem 2048</span><br><span class="line"># 为中间ca生成csr文件</span><br><span class="line">openssl req -new -key intermediate_ca_key.pem -out intermediate_ca.csr</span><br></pre></td></tr></table></figure>

<p><strong>生成 SAN 配置文件</strong>(针对后续https，能在浏览器正常打开网页，需配置SAN，不能直接用openssl直接让root给中间ca颁发证书)</p>
<p>创建intermediate_openssl.cnf</p>
<p>&#x2F;&#x2F;若在本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ v3_req ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[ alt_names ]</span><br><span class="line">DNS.1   = localhost</span><br><span class="line">IP.1    = 127.0.0.1</span><br><span class="line">IP.2    = ::1</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;若在服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ v3_req ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[ alt_names ]</span><br><span class="line">IP.1    = 47.106.143.170</span><br></pre></td></tr></table></figure>

<p>使用 root_ca 的私钥和根证书为网站签署一个新的证书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -in intermediate_ca.csr -CA root_ca_cert.pem -CAkey root_ca_key.pem -CAcreateserial -out intermediate_cert.pem -days 365 -sha256 -extfile intermediate_openssl.cnf -extensions v3_req</span><br></pre></td></tr></table></figure>





<h4 id="关于https"><a href="#关于https" class="headerlink" title="关于https"></a>关于https</h4><p>安装插件 <code>django-sslserver</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-sslserver</span><br></pre></td></tr></table></figure>

<p>检查你的 Django 项目的 <code>settings.py</code> 文件，确保 <code>sslserver</code> 已添加到 <code>INSTALLED_APPS</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    &#x27;sslserver&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>以及添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECURE_SSL_REDIRECT = True  # 强制重定向到 HTTPS</span><br><span class="line">SECURE_HSTS_SECONDS = 3600  # 启用 HSTS，设置过期时间</span><br><span class="line">SECURE_HSTS_INCLUDE_SUBDOMAINS = True  # 对子域名启用 HSTS</span><br><span class="line">SECURE_HSTS_PRELOAD = True  # 允许浏览器预加载 HSTS</span><br><span class="line">SECURE_PROXY_SSL_HEADER = (&#x27;HTTP_X_FORWARDED_PROTO&#x27;, &#x27;https&#x27;)  # 代理配置</span><br></pre></td></tr></table></figure>

<p>找到这个文件D:\python3.12\Lib\site-packages\sslserver\management\commands\runsslserver.py</p>
<p>venv&#x2F;lib&#x2F;python3.12&#x2F;site-packages&#x2F;sslserver&#x2F;management&#x2F;commands&#x2F;runsslserver.py</p>
<p>找到下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SecureHTTPServer(ThreadedWSGIServer):</span><br><span class="line">    def __init__(self, address, handler_cls, certificate, key, ipv6=False):</span><br><span class="line">        super(SecureHTTPServer, self).__init__(address, handler_cls, ipv6=ipv6)</span><br><span class="line">        self.socket = ssl.wrap_socket(self.socket, certfile=certificate,</span><br><span class="line">                                      keyfile=key, server_side=True,</span><br><span class="line">                                      ssl_version=_ssl_version,</span><br><span class="line">                                      cert_reqs=ssl.CERT_NONE)</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SecureHTTPServer(ThreadedWSGIServer):</span><br><span class="line">    def __init__(self, address, handler_cls, certificate, key, ipv6=False):</span><br><span class="line">        super(SecureHTTPServer, self).__init__(address, handler_cls, ipv6=ipv6)</span><br><span class="line">        </span><br><span class="line">        # 创建 SSL 上下文</span><br><span class="line">        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)</span><br><span class="line">        context.load_cert_chain(certfile=certificate, keyfile=key)</span><br><span class="line">        context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1  # 禁用过时的 TLS 版本</span><br><span class="line"></span><br><span class="line">        # 替换原来的 wrap_socket</span><br><span class="line">        self.socket = context.wrap_socket(self.socket, server_side=True)</span><br></pre></td></tr></table></figure>

<p>说明<br>为什么要用 ssl.SSLContext 替换 ssl.wrap_socket？</p>
<p>​	ssl.wrap_socket 是一种旧方法，已经不推荐使用。ssl.SSLContext 是更现代化、更灵活的方式。<br>​	在 Python 3.12 中，ssl.wrap_socket 可能已经被移除或有兼容性问题。</p>
<p>主要调整点</p>
<p>​	使用 ssl.SSLContext 创建上下文，指定协议为 ssl.PROTOCOL_TLS_SERVER。<br>​	调用 context.load_cert_chain 加载证书和密钥。<br>​	使用 context.wrap_socket 替代 ssl.wrap_socket。</p>
<p>TLS 版本配置</p>
<p>​	使用 context.options |&#x3D; ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 禁用过时的 TLS 版本（可选，但推荐）。</p>
<h4 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h4><p>创建一个虚拟环境来隔离项目的 Python 环境，避免修改系统的 Python。</p>
<ol>
<li><p>**安装 <code>python3-venv</code>**（如果未安装）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install python3-venv</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建虚拟环境</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m venv venv</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>激活虚拟环境</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source venv/bin/activate</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py runsslserver 0.0.0.0:443 --certificate /var/www/CA/templates/ca/guet_ca_cert.pem --key /var/www/CA/templates/ca/guet_ca_key.pem</span><br></pre></td></tr></table></figure>



<p>&#x2F;var&#x2F;www&#x2F;CA&#x2F;templates&#x2F;ca&#x2F;root_ca_cert.pem</p>
<p>关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo lsof -i :8080</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill 【PID】</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p>要让 Django 项目在阿里云服务器上持续运行，即使你断开与服务器的连接，可以使用一些方法将其作为后台服务运行。常见的方式有使用 <strong><code>tmux</code></strong> 或 **<code>screen</code>**（用于管理终端会话），以及使用 **<code>systemd</code>**（用于设置长期服务）。下面我将介绍几种方法。</p>
<h4 id="使用-tmux"><a href="#使用-tmux" class="headerlink" title="使用 tmux"></a>使用 <code>tmux</code></h4><p><code>tmux</code> 是一个终端复用器，能够让你在后台运行程序并保持其持续运行，即使关闭了 SSH 会话。</p>
<h4 id="1-安装-tmux"><a href="#1-安装-tmux" class="headerlink" title="1. 安装 tmux"></a>1. 安装 <code>tmux</code></h4><p>如果你的服务器上没有安装 <code>tmux</code>，可以先安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash复制代码sudo apt update</span><br><span class="line">sudo apt install tmux</span><br></pre></td></tr></table></figure>

<h4 id="2-启动-tmux-会话"><a href="#2-启动-tmux-会话" class="headerlink" title="2. 启动 tmux 会话"></a>2. 启动 <code>tmux</code> 会话</h4><p>在服务器上创建一个新的 <code>tmux</code> 会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">tmux new -s my_django_session</span><br></pre></td></tr></table></figure>

<p>这里的 <code>my_django_session</code> 是会话的名字，你可以随意命名。</p>
<h4 id="3-运行-Django-项目"><a href="#3-运行-Django-项目" class="headerlink" title="3. 运行 Django 项目"></a>3. 运行 Django 项目</h4><p>在 <code>tmux</code> 会话中运行你的 Django 项目（例如，使用 <code>runserver</code> 或 <code>runsslserver</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">python3 manage.py runserver 0.0.0.0:8080</span><br></pre></td></tr></table></figure>

<h4 id="4-分离-tmux-会话"><a href="#4-分离-tmux-会话" class="headerlink" title="4. 分离 tmux 会话"></a>4. 分离 <code>tmux</code> 会话</h4><p>你可以按下 <code>Ctrl + B</code>，然后按 <code>D</code>，这会使你“分离”出 <code>tmux</code> 会话，项目继续在后台运行。</p>
<h4 id="5-恢复会话"><a href="#5-恢复会话" class="headerlink" title="5. 恢复会话"></a>5. 恢复会话</h4><p>如果你需要重新连接到 <code>tmux</code> 会话，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">tmux attach -t my_django_session</span><br></pre></td></tr></table></figure>

<h4 id="6-关闭会话"><a href="#6-关闭会话" class="headerlink" title="6. 关闭会话"></a>6. 关闭会话</h4><p>当你不再需要 <code>tmux</code> 会话时，可以输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>这将关闭会话并终止 Django 项目。</p>
<p>https默认443端口</p>
<p>django</p>
<p>pymysql</p>
<p>django-sslserver</p>
<p>cryptography</p>
<p>requests</p>
<p>&#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;000-default.conf</p>
<p>增加重定向</p>
<p># 其他配置项（如果有的话）    ServerName 47.106.143.170     # 重定向 HTTP 到 HTTPS    Redirect permanent &#x2F; <a href="https://47.106.143.170/">https://47.106.143.170/</a></p>
<p>CA.conf</p>
<p>监听端口443，配置证书跟私钥</p>
<p><strong>SAN（Subject Alternative Name）</strong> 是 SSL&#x2F;TLS 证书中的一个字段，它用于指定证书可以用于多个不同的域名、IP 地址、DNS 名称等。SAN 字段是证书扩展的一部分，允许一个单一的证书支持多个域名或服务。这在很多实际场景中非常有用，尤其是当你希望通过一个证书来保护多个子域名或服务时。</p>
<h3 id="SAN-字段的作用："><a href="#SAN-字段的作用：" class="headerlink" title="SAN 字段的作用："></a>SAN 字段的作用：</h3><ol>
<li><strong>多域名支持</strong>：<ul>
<li>SAN 字段可以包含多个域名，使得一个证书可以同时支持多个不同的域名或子域名。例如，一个证书可以同时保护 <code>example.com</code>、<code>www.example.com</code> 和 <code>blog.example.com</code> 等多个域名。</li>
</ul>
</li>
<li><strong>灵活性</strong>：<ul>
<li>SAN 提供了对多种类型的名称的支持，不仅限于域名（DNS 名称），还可以包括 IP 地址、电子邮件地址等。</li>
<li>对于 IP 地址，可以为服务器的多个 IP 地址生成一个证书，而不必为每个 IP 地址生成单独的证书。</li>
</ul>
</li>
<li><strong>用于不同类型的连接</strong>：<ul>
<li>除了 DNS 名称，SAN 字段还支持诸如 <strong>URI</strong>、<strong>IP 地址</strong>、<strong>电子邮件地址</strong> 等形式的标识符。</li>
</ul>
</li>
</ol>
<h3 id="典型的-SAN-字段内容："><a href="#典型的-SAN-字段内容：" class="headerlink" title="典型的 SAN 字段内容："></a>典型的 SAN 字段内容：</h3><ul>
<li><strong>DNS 名称（DNS Name）</strong>：列出证书所保护的域名或子域名。</li>
<li><strong>IP 地址（IP Address）</strong>：列出证书可以用于的 IP 地址。</li>
<li><strong>电子邮件地址（Email Address）</strong>：证书也可以绑定到特定的电子邮件地址。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>假设你有一个证书需要保护以下几个域名：</p>
<ul>
<li><code>example.com</code></li>
<li><code>www.example.com</code></li>
<li><code>api.example.com</code></li>
</ul>
<p>在证书的 SAN 字段中，你可以列出这些域名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS:example.com</span><br><span class="line">DNS:www.example.com</span><br><span class="line">DNS:api.example.com</span><br></pre></td></tr></table></figure>

<p>此外，假设你希望证书同时支持某个 IP 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS:example.com</span><br><span class="line">DNS:www.example.com</span><br><span class="line">IP:192.168.1.1</span><br></pre></td></tr></table></figure>

<h3 id="SAN-字段与传统的-Common-Name（CN）字段的关系："><a href="#SAN-字段与传统的-Common-Name（CN）字段的关系：" class="headerlink" title="SAN 字段与传统的 Common Name（CN）字段的关系："></a>SAN 字段与传统的 Common Name（CN）字段的关系：</h3><p>在旧版本的 SSL&#x2F;TLS 证书中，<strong>Common Name（CN）</strong> 字段通常用来指定证书所保护的域名。虽然仍然可以在 CN 字段中指定域名，但现代 SSL&#x2F;TLS 证书已经逐步将 SAN 字段作为域名验证的首选方法。</p>
<p><strong>为什么 SAN 更重要：</strong></p>
<ul>
<li><strong>CN 字段的限制</strong>：传统的证书只允许一个 CN，即一个单一的域名，而 SAN 字段可以支持多个域名、IP 地址等。</li>
<li><strong>浏览器和客户端的要求</strong>：现在的大多数浏览器和客户端都要求证书包含 SAN 字段，而 CN 字段已经不再是唯一的验证域名的来源。</li>
</ul>
<h3 id="在证书申请中的作用："><a href="#在证书申请中的作用：" class="headerlink" title="在证书申请中的作用："></a>在证书申请中的作用：</h3><p>当你向证书颁发机构（CA）申请证书时，如果你需要证书保护多个域名或 IP 地址，必须在证书申请中明确列出这些名称，并将它们包含在 SAN 字段中。</p>
<p>例如，使用 <strong>OpenSSL</strong> 工具生成 CSR 时，可以指定 SAN 字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line">x509_extensions = v3_req</span><br><span class="line"></span><br><span class="line">[ v3_req ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[ alt_names ]</span><br><span class="line">DNS.1 = example.com</span><br><span class="line">DNS.2 = www.example.com</span><br><span class="line">DNS.3 = api.example.com</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>SAN</strong> 是 SSL&#x2F;TLS 证书中的一个扩展字段，用于指定证书所保护的多个域名、IP 地址、电子邮件地址等。</li>
<li>它提供了更大的灵活性，允许一个证书支持多个服务或域名，避免了为每个域名单独申请证书的麻烦。</li>
<li>在现代证书中，SAN 字段比 CN 字段更为重要，因为它可以支持多个名称，并且大多数浏览器和客户端都依赖于 SAN 来验证证书的有效性。</li>
</ul>
<p>apache重启</p>
<p>sudo systemctl restart apache2</p>
]]></content>
      <tags>
        <tag>CA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/10/31/helloworld/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Illustrate"><a href="#Illustrate" class="headerlink" title="Illustrate"></a>Illustrate</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](image.png)</span><br></pre></td></tr></table></figure>

<p><img src="/test.png" alt="1"></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql_server</title>
    <url>/2024/12/11/mysql-server/</url>
    <content><![CDATA[<p>​	如何在阿里云轻量级服务器(ubuntu)上添加mysql远程服务</p>
<ol>
<li><p>安装mysql</p>
<ol>
<li><p>更新软件包列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>


</li>
<li><p>安装mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure>


</li>
<li><p>检查mysql状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>配置mysql允许远程访问</p>
<ol>
<li><p>编辑mysql配置文件</p>
<p>打开mysql配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>

<p>找到以下行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind-address = 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>将其改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind-address = 0.0.0.0</span><br></pre></td></tr></table></figure>


</li>
<li><p>重启mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>创建用户并赋权</p>
<ol>
<li><p><strong>登录mysql</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>创建一个用户并允许远程访问</strong>替换 <code>username</code> 和 <code>password</code> 为实际用户名和密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;username&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;; GRANT ALL PRIVILEGES ON *.* TO &#x27;username&#x27;@&#x27;%&#x27; WITH GRANT OPTION; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>ps: 可利用如下命令更新赋予全部权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;caserver&#x27;@&#x27;%&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>测试新用户</strong> 退出 MySQL 并使用新用户重新登录（可在服务器上测试）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u username -p</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>配置防火墙</p>
<ol>
<li><p>开放mysql端口 （默认3306）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 3306</span><br></pre></td></tr></table></figure>


</li>
<li><p>检查防火墙状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>（阿里云）开放安全组</strong> 在阿里云管理控制台：</p>
<ul>
<li>打开您的轻量应用服务器实例。</li>
<li>进入<strong>防火墙规则</strong>或<strong>安全组规则</strong>页面。</li>
<li>添加规则：允许 <strong>3306</strong> 端口的入站访问。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>测试：在本地的navicat中添加数据库</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区溢出</title>
    <url>/2025/05/26/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<ol>
<li>什么是缓冲区溢出漏洞？</li>
<li>什么是栈溢出？栈溢出漏洞如何利用？</li>
<li>什么是堆溢出？堆溢出漏洞如何利用？</li>
<li>什么是格式化字符串漏洞？该漏洞如何利用？</li>
<li>针对缓冲区溢出漏洞，<code>Windows</code>平台设置了哪些保护机制？</li>
</ol>
<p>![[Pasted image 20250604180353.png]]</p>
<ul>
<li>栈区：该区域内存由系统自动分配，用于动态存储函数之间的调用关系</li>
<li>堆区：该区域内存由进程利用相关函数或运算符动态申请，用完后释放并归还给堆区。例如，<code>C</code>语言中用<code>malloc/free</code>函数，<code>C++</code>语言中用<code>new/delete</code>运算符申请的空间就在堆区。</li>
<li>代码区：存放程序汇编后的机器代码和只读数据</li>
<li>数据区：用于存储全局变量和静态变量</li>
</ul>
<h6 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h6><ul>
<li>程序中所使用的缓冲区可以是堆区和栈区，也可以是存放静态变量的数据区。</li>
<li>由于进程中各个区域都有自己的用途，根据缓冲区利用的方法和缓冲区在内存中所属区域，其可分为栈溢出和堆溢出。</li>
</ul>
<h6 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h6><ul>
<li>缓冲区溢出漏洞就是在向缓冲区写入数据时，由于没有做边界检查，导致写入缓冲区的数据超过预先分配的边界，从而使溢出数据覆盖在合法数据上而引起系统异常的一种现象。</li>
<li>目前，缓冲区溢出漏洞普遍存在于各种操作系统<code>（Windows、Linux、Solaris、Free BSD、HP-UX以及IBM AIX）</code>，以及运行在操作系统上的各类应用程序中。</li>
</ul>
<h6 id="函数的栈帧"><a href="#函数的栈帧" class="headerlink" title="函数的栈帧"></a>函数的栈帧</h6><ul>
<li>在程序设计中，栈通常指的是一种后进先出的数据结构。</li>
<li>相对于广义的栈而言，栈帧是操作系统为进程中的每个函数调用划分的一个空间，每个栈帧都是一个独立的栈结构，而系统栈则是这些函数调用栈帧的集合。</li>
<li>系统栈由系统自动维护，用于实现高级语言中函数的调用。</li>
<li>当函数被调用时，系统会为这个函数开辟一个新的栈帧，并把它压入栈区中，所以正在运行的函数总是在系统栈区的栈顶（本书称为：当前栈帧）。当函数返回时，系统会弹出该函数所对应的栈帧空间。</li>
<li>栈帧的生长方向是从高地址向低地址增长的。</li>
<li><code>ESP</code>：扩展栈指针<code>（Extended Stack Pointer）</code>寄存器，其存放的指针指向当前栈帧的栈顶。</li>
<li><code>EBP</code>：扩展基址指针<code>（Extended Base Pointer）</code>寄存器，其存放的指针指向当前栈帧的栈底。</li>
<li>显然，<code>ESP</code>与<code>EBP</code>之间的空间即为当前栈帧空间。</li>
</ul>
<p>![[Pasted image 20250604202245.png]]一个函数栈帧中主要包含如下信息。<br>1）前一个栈帧的栈底位置，即前栈帧<code>EBP</code>，用于在函数调用结束后恢复主调函数的栈帧（前栈帧的栈顶可计算得到）。<br>2）该函数的局部变量。<br>3）函数调用的参数。<br>4）函数的返回地址<code>RET</code>，用于保存函数调用前指令的位置，以便函数返回时能恢复到调用前的代码区中继续执行指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fun(int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int local;</span><br><span class="line">	locam=m+n;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t1=0x1111;</span><br><span class="line">	int t2=0x2222;</span><br><span class="line">	fun(t1,t2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用步骤：<br>![[Pasted image 20250604203340.png]]<br>1）参数入栈。将被调用函数的实际参数从右到左依次压入主调函数的函数栈帧中。<br>2）返回地址RET入栈。将当前指令的下一条指令地址压入主调函数的函数栈帧中。<br>3）代码区跳转。CPU从当前代码区跳转到被调用函数的入口，EIP指向被调用函数的入口处。<br>4）将当前栈帧调整为被调用函数的栈帧</p>
<p>![[Pasted image 20250605164737.png]]</p>
<p>1）将主调函数的栈帧底部指针EBP入栈，以便被调用函数返回时恢复主调函数的栈帧。<br>2）更新当前栈帧底部：将主调函数的栈帧顶部指针ESP的值赋给EBP，作为新的当前栈帧（即被调用函数的栈帧）底部。<br>3）为新栈帧分配空间：ESP 减去适当的值，作为新的当前栈帧的栈顶。<br>4）将当前栈帧调整为被调用函数的栈帧</p>
<p>返回主函数的步骤：<br>1）保存返回值。将函数的返回值保存在寄存器EAX 中。<br>2）弹出当前栈帧，将前一个栈帧（即主调函数栈帧）恢复为当前栈帧</p>
<h6 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h6><p><strong>栈溢出漏洞基本原理</strong></p>
<ul>
<li>在函数的栈帧中，局部变量是顺序排列的，局部变量下面紧跟着的是前栈帧EBP以及函数返回地址RET。</li>
<li>如果这些局部变量为数组，由于存在越界的漏洞，那么越界的数组元素将会覆盖相邻的局部变量，甚至覆盖前栈帧EBP以及函数返回地址RET，从而造成程序的异常。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">	char password[6]=&quot;ABCDE&quot;;</span><br><span class="line">	char str[6];</span><br><span class="line">	gets(str);</span><br><span class="line">	str[5]=&#x27;\0&#x27;;</span><br><span class="line">	if(strcmp(str,password)==0)</span><br><span class="line">		print(&quot;OK.\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		print(&quot;NO.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20250605171409.png]]</p>
<p>由于C语言中没有数组越界检查，因此，当用户输入的口令超过2个字节时，将会覆盖紧邻的password数组。如图3-10<br>![[Pasted image 20250605171414.png]]</p>
<p>如果用户增加输入字符串的长度，将会超过password数组的边界，从而覆盖前栈帧EBP，甚至是覆盖返回地址RET。当返回地址RET被覆盖后，将会造成进程执行跳转的异常。如图3-11</p>
<p>![[Pasted image 20250605171514.png]]</p>
<p><strong>栈溢出漏洞的利用</strong></p>
<ul>
<li>实际攻击中，攻击者通过缓冲区溢出改写的目标往往不是某一个变量，而是栈帧高地址的EBP和函数的返回地址等值。通过覆盖程序中的函数返回地址和函数指针等值，攻击者可以直接将程序跳转到其预先设定或已经注入到目标程序的代码上去执行。</li>
<li>栈溢出攻击是一种利用栈溢出漏洞所进行的攻击行动，目的在于扰乱具有某些特权运行的程序的功能，使得攻击者取得程序的控制权，如果该程序具有足够的权限，那么整个主机就被控制了。</li>
</ul>
<p>JMP ESP覆盖方法</p>
<ul>
<li>在实际的漏洞利用中，由于动态链接库的装入和卸载等原因，Windows进程的函数栈帧可能发生移位，即Shellcode在内存中的地址是动态变化的，所以上述采用直接赋地址值的简单方式在以后的运行过程中会出现跳转异常。</li>
<li>可以在覆盖返回地址的时候用系统动态链接库中某条处于高地址且位置固定的跳转指令所在的地址进行覆盖，然后再通过这条跳转指令指向动态变化的Shellcode地址。这样便能够确保程序执行流程在目标系统运行时可以被如期进行。</li>
<li>JMP ESP覆盖方法是覆盖函数返回地址的一种攻击方式。考虑到函数返回时ESP总是指向函数返回后的下一条指令，根据这一特点，如果用指令JMP ESP的地址覆盖返回地址，则函数也可以跳转到函数返回后的下一条指令，而从函数返回后的下一条指令开始都已经被Shellcode所覆盖，那么程序就可以跳转到该Shellcode上并执行，从而实现了程序流程的控制。</li>
</ul>
<p>SEH结构<br>异常处理结构体SEH是Windows异常处理机制所采用的重要数据结构:<br>SEH结构体存放在栈中，栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单向链表;<br>位于链表最顶端的SEH通过线程环境块TEB-Thread Environment Block）0字节偏移处的指针标识;<br>每个SEH包含两个DWORD指针：SEH链表指针和异常处理函数句柄，共8个字节。<br>![[Pasted image 20250605171836.png]]SEH覆盖方法</p>
<ul>
<li>SEH覆盖方法就是覆盖异常处理程序地址的一种攻击方式。由于SEH结构存放在栈中，因此攻击者可以利用栈溢出漏洞，设计特定的溢出数据，将SEH中异常函数的入口地址覆盖为Shellcode的起始地址或可以跳转到Shellcode的跳转指令地址，从而导致程序发生异常时，Windows异常处理机制执行的不是预设的异常处理函数，而是Shellcode。</li>
</ul>
<h6 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h6><p>![[Pasted image 20250605172058.png]]</p>
<p>栈：由系统自动分配。例如，声明一个局部变量<code>int b</code>，系统自动在栈中为<code>b</code>开辟空间。<br>堆：需要程序员自己申请，并指明大小，在&#96;&#96;c中<code>malloc</code>函数，如<br><code>p1 = (char *)malloc(10)</code>。</p>
<p>![[Pasted image 20250605172254.png]]<br>堆区一开始的堆表区中有一个<code>128</code>项的指针数组，被称为空表索引<code>（freelistarray）</code>。<br>该数组的每一项包括两个指针，用于表示一个空表。<br>空表索引的第二项<code>free[1]</code>标识了堆中所有大小为8字节的空闲堆块，之后每个索引项指示的空闲块递增8字节。<br>![[Pasted image 20250605172258.png]]</p>
<p>占用态堆块的数据结构<br>![[Pasted image 20250606213454.png]]</p>
<p>空闲块堆块的数据结构<br>![[Pasted image 20250606213530.png]]</p>
<p>堆块三类操作：堆块分配、堆块释放和堆块合并，归根结底是对空表链的修改。这些修改无外乎要向链表里链入和卸下堆块。<br>从链表上卸载<code>（unlink）</code>一个节点的时候会发生如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node—&gt;blink—&gt;flink = node—&gt;flink ;</span><br><span class="line">node—&gt;flink—&gt;blink = node—&gt;blink ;</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20250605172654.png]]</p>
<p>如果我们通过堆溢出(申请了两个堆块(一般大小一致)恰好相邻，释放掉后面的一个块，这个快会被回收到空闲块链表，向申请的前一个块中放入过量数据，此时数据就会溢出到后面已经释放的空闲表，修改其表头)覆写了一个空闲堆块的块首的前向指针flink和后向指针blink，构造一个地址和一个数据，当这个空闲堆块从链表里卸下的时候，就获得一次向内存构造的任意地址写入一个任意数据的机会<code>-Arbitrary Dword Reset（又称Dword Shoot）</code>。<br>![[Pasted image 20250605172750.png]]<br>![[Pasted image 20250605173121.png]]<br>基于<code>Dword Shoot</code>攻击，攻击者甚至可以劫持进程，运行植入的恶意代码。比如，当构造的地址为重要函数调用地址、栈帧中函数返回地址、栈帧中SEH的句柄等时，写入的任意数据可能就是恶意代码的入口地址。<br><a href="https://blog.csdn.net/huxyc/article/details/134795336#t0">更加详细的堆溢出参考</a></p>
<p><strong>堆溢出漏洞利用</strong><br>栈溢出和堆溢出相结合的一种技术。<br>首先将<code>shellcode</code>放置到堆中，然后在栈溢出时，控制函数执行流程，跳转到堆中执行<code>shellcode</code>。</p>
<h6 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h6><ul>
<li>格式化字符串（简称格式化串）的漏洞本身并不算缓冲区溢出漏洞，这里作为一类比较典型的系统函数存在的漏洞做一介绍。</li>
<li>格式化串漏洞的产生源于数据输出函数中对输出格式解析的缺陷，其根源也是C语言中不对数组边界进行检查的缓冲区错误。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a=44,b=77;</span><br><span class="line">	printf(&quot;a=%d,b=%d\n&quot;,a,b);</span><br><span class="line">	printf(&quot;a=%d,b=%d\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>printf</code>函数进行格式化输出时，会根据格式化串中的格式化控制符在栈上取相应的参数，然后按照所需格式输出。<br>如果函数调用给出的输出数据列表少于格式控制符个数，甚至于没有给出输出数据列表，系统仍然会按照格式化串中格式化控制符的个数输出栈中的数据。<br>![[Pasted image 20250605175916.png]]</p>
<p><strong>格式化串漏洞利用</strong><br>格式化串漏洞的利用可以通过如下方法实现：</p>
<ul>
<li>通过改变格式化串中输出参数的个数实现修改指定地址的值：可以修改填充字符串长度实现；也可以通过改变输出的宽度实现，如<code>%8d</code>。</li>
<li>通过改变格式化串中格式符的个数，调整格式符对应参数在栈中位置，从而实现对栈中特定位置数据的修改。<br><a href="https://zhuanlan.zhihu.com/p/465896542">详细说明</a></li>
</ul>
<h6 id="Windows平台溢出漏洞保护机制"><a href="#Windows平台溢出漏洞保护机制" class="headerlink" title="Windows平台溢出漏洞保护机制"></a>Windows平台溢出漏洞保护机制</h6><p><strong>栈溢出检测选项&#x2F;GS</strong><br>调用函数时将一个随机生成的秘密值存放在栈上，当函数返回时，检查这个堆栈检测仪的值是否被修改，以此判断是否发生了栈溢出。<br>![[Pasted image 20250605201901.png]]</p>
<ul>
<li>如果编译器启用了<code>/GS</code>选项，那么当程序编译时，它首先会计算出程序的一个安全<code>Cookie</code>；</li>
<li>然后将安全<code>Cookie</code>保存在加载模块的数据区中，在函数调用之时，这个<code>Cookie</code>被复制到栈中，位于<code>RET</code>返回地址、<code>EBP</code>与局部变量之间；</li>
<li>在函数调用结束时，程序会把这个Cookie和事先保存的<code>Cookie</code>进行比较。如果不相等，就说明进程的系统栈被破坏，需要终止程序运行。</li>
</ul>
<p>在典型的缓冲区溢出中，栈上的返回地址会被数据所覆盖，但在返回地址被覆盖之前，安全<code>Cookie</code>早已经被覆盖了，因此在函数调用结束时检查<code>Cookie</code>会发现异常，并终止程序，这将导致漏洞利用的失效。</p>
<p>![[Pasted image 20250605201904.png]]</p>
<p>对抗<code>/GS</code>保护：围绕<code>Cookie</code>值展开的。</p>
<ul>
<li>猜测<code>Cookie</code>值</li>
<li>通过同时替换栈中的<code>Cookie</code>和<code>Cookie</code>副本</li>
<li>覆盖<code>SEH</code>绕过<code>Cookie</code>检查</li>
<li>覆盖父函数的栈数据绕过<code>Cookie</code>检查</li>
</ul>
<p><strong>数据执行保护<code>DEP（Data Execution Prevention）</code></strong><br>通过使可写内存不可执行或使可执行内存不可写来消除类似的威胁。<br><code>Visual Studio</code>编译器提供了一个链接标志<code>（/NXCOMPAT）</code>，可以在生成目标应用程序时使程序启用<code>DEP</code>保护。<br>![[Pasted image 20250605202331.png]]</p>
<p>对抗数据执行保护DEP：执行已经加载的模块中的指令或调用系统函数则不受DEP影响，而栈上的数据只需作为这些函数&#x2F;指令的参数即可。</p>
<ul>
<li>利用ret-to-libc执行命令或进行API调用，如调用WinExec实现执行程序。</li>
<li>将包含Shellcode的内存页面标记为可执行，然后再跳过去执行。 </li>
<li>通过分配可执行内存，再将Shellcode复制到内存区域，然后跳过去执行。</li>
<li>先尝试关闭当前进程的DEP保护，然后再运行Shellcode。</li>
</ul>
<p><strong>地址空间布局随机化ASLR</strong><br>通过对堆、栈、共享库映射等线性区域布局的随机化，增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止漏洞利用的目的。<br>在目前的VS编译器中，均提供了连接选项<code>/DYNAMICBASE</code>。<br>![[Pasted image 20250605202430.png]]<br>ASLR机制的缺陷和绕过方法</p>
<ul>
<li>对本地攻击者无能为力</li>
<li>造成内存碎片的增多</li>
<li>利用没有采用&#x2F;DYNAMICBASE选项保护的模块做跳板</li>
</ul>
<p><strong>安全结构化异常处理SafeSEH</strong></p>
<ul>
<li>SafeSEH保护机制的作用是防止覆盖和使用存储栈上的SEH结构。</li>
<li>其实现原理是，编译器在链接生成二进制IMAGE时，把所有合法的异常处理函数的地址解析出来制成一张安全的SEH表，保存在程序的IMAGE数据块里面，当程序调用异常处理函数时会将函数地址与安全SEH表中的地址进行匹配，检查调用的异常处理函数是否位于该表中。</li>
<li>微软在.Net编译器中加入了&#x2F;safeSEH连接选项。</li>
</ul>
<p>对抗SafeSEH机制的方法</p>
<ul>
<li>利用未启用SafeSEH的模块作为跳板进行绕过</li>
<li>利用加载模块之外的地址进行绕过</li>
</ul>
<p>增强缓解体验工具包EMET<br>EMET的基本保护功能介绍如下。</p>
<ul>
<li>增强型DEP</li>
<li>SafeSEH的升级版——SEHOP</li>
<li>强制性ASLR</li>
<li>HeapSpray防护</li>
</ul>
]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>获取kernel32基址</title>
    <url>/2024/12/11/%E8%8E%B7%E5%8F%96kernel32%E5%9F%BA%E5%9D%80/</url>
    <content><![CDATA[<span id="more"></span>



<p><strong><code>kernel32.dll</code>中两个重要函数</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HMODULE LoadLibraryA([in] LPCSTR lpLibFileName);</span><br></pre></td></tr></table></figure>
<p>在运行时动态加载指定的 <code>DLL</code>，并获得该 <code>DLL</code> 的模块句柄。加载 <code>DLL</code> 可以提供程序所需的额外功能或资源，增强程序的灵活性和可扩展性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">  [in] HMODULE hModule,</span><br><span class="line">  [in] LPCSTR  lpProcName</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>从指定的动态链接库<code>(DLL)</code>检索导出函数 (也称为过程) 或变量的地址。</p>
<p><strong>获取<code>kernel32.dll</code>基址-暴力搜索</strong><br>原理：</p>
<ul>
<li>每个进程必定加载<code>kernel32.dll</code></li>
<li>且加载在<code>xxxx0000h</code>处-高端内存，<code>MIN_KERNEL_SEARCH_BASE=70000000H</code> ，分配粒度是<code>10000h</code></li>
<li>进程启动时，<code>kernel32</code>会调用程序入口点，其返回地址在栈中指向<code>kernel32</code>内部。</li>
<li><code>kernel32.dll</code>也是标准的<code>PE</code>结构文件，存在<code>MZ</code>头</li>
</ul>
<p><strong>获取<code>kernel32.dll</code>基址-<code>PEB</code>搜索</strong></p>
<ul>
<li>基于<code>PEB</code>搜索-<code>TEB</code>（<code>Thread Environment Block</code>，线程环境块）系统在此<code>TEB</code>中保存频繁使用的线程相关的数据。可通过<code>CPU</code>的<code>FS</code>寄存器来访问该段，一般存储在<code>[FS:0]</code></li>
<li><code>PEB</code>（<code>Process Environment Block</code>，进程环境块）存放进程信息，每个进程都有自己的<code>PEB</code>信息。位于用户地址空间。可在<code>TEB</code>结构地址偏移<code>0x30</code>处获得<code>PEB</code>的地址位置。</li>
<li><code>PEB_LDR_DATA</code> 结构体(包含载入的<code>dll</code>信息)，里面包含了三个双向链表，<br><code>InLoadOrderModuleList</code> 按加载顺序的模块链表<br><code>InMemoryOrderModuleList</code> 按内存位置的模块链表<br><code>InInitializationOrderModuleList</code> 按初始化顺序<br>该结构体在<code>PEB</code>中偏移<code>0x0C</code>的位置</li>
</ul>
<p>常规结构如下：<br>![[5600d7f10843cf4bdc8f6d9990a33bc1.png]]</p>
<p>汇编获取<code>kernel32.dll</code>基址示例：</p>
<pre><code>mov eax, [fs:30h]        指向PEB
mov eax, [eax + 0ch]  指向Ldr
mov eax, [eax + 14h]  指向InMemoryOrderModuleList
mov eax, [eax]             本进程模块
mov eax, [eax]              ntdll模块
mov eax, [eax -8h + 18h]   kernel32.Dll基址
</code></pre>
]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程笔记</title>
    <url>/2024/11/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>笔记</p>
<p>逆向工程课笔记</p>
<span id="more"></span>

<h3 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h3><p>1 qword &#x3D; 2 dword &#x3D; 4 word &#x3D; 8 byte &#x3D; 64 bit  </p>
<p>小端存储：数据的<strong>低位</strong>放在<strong>低地址</strong>空间，数据的<strong>高位</strong>放在<strong>高地址</strong>空间</p>
<p>大端存储：数据的<strong>高位</strong>放在<strong>低地址</strong>空间，数据的<strong>低位</strong>放在<strong>高地址</strong>空间</p>
<p><strong>eg:存放的时候是以一个存储单元为单位来存放，存储单元内部不需要再转变顺序！！！</strong></p>
<p>例如低位0001-0101存放在0号地址，不需要把它变成1010-1000！！！</p>
<p>eg:读取时都是从低地址开始读数据</p>
<p>汇编代码示例：</p>
<img src="images/1.png" alt="1" style="zoom:67%;" />

<p>在汇编代码中定义变量，db 表示字节类型，dw 表示字类型，dd 表示双字类型。而在表示数值的时候，以h 结尾的表示十六进制数，以 b 结尾的表示 2 进制数，结尾处没有修饰符的默认为十进制数。</p>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><h5 id="八个通用寄存器"><a href="#八个通用寄存器" class="headerlink" title="八个通用寄存器"></a>八个通用寄存器</h5><p><img src="/images/2.png"></p>
<p>EAX：累加器，在乘法和除法指令中被自动使用；在 Win32 中，一般用在函数的返回值中。</p>
<p>EBX：基址寄存器，DS 段中的数据指针。</p>
<p>ECX：计数器，CPU 自动使用 ECX 作为循环计数器，在字符串和循环操作中常用，在循环指令（LOOP）或串操作中，ECX 用来进行循环计数，每执行一次循环，ECX 都会被CPU 自动减一。</p>
<p>EDX：数据寄存器。</p>
<p>​	以上 4 个寄存器主要用在算数运算与逻辑运算指令中，常用来保存各种需要计算的值。</p>
<p>EBP：扩展基址指针寄存器，SS 段中堆栈内数据指针。EBP 由高级语言用来引用参数和局部变量，通常称为堆栈基址指针寄存器。</p>
<p>ESP：堆栈指针寄存器，SS 段中堆栈指针。ESP 用来寻址堆栈上的数据，ESP 寄存器一般不参与算数运算，通常称为堆栈指针寄存器。</p>
<p>ESI：源变址寄存器，字符串操作源指针。</p>
<p>EDI：目的变址寄存器，字符串操作目标指针。</p>
<p>​	以上 4 个寄存器主要用作保存内存地址的指针。</p>
<p>ESI 和 EDI 通常用于内存数据的传递，因此才被称为源指针寄存器和目的指针寄存器。ESI和 EDI 与特定的指令 LODS、STOS、REP、MOVS 等一起使用，主要用于内存中数据的复制。</p>
<p>ESP 指示堆栈区域的栈顶地址，PUSH、POP、CALL、RET 等指令可以直接用来操作 ESP指针。EBP 指示堆栈区域的基地址。</p>
<p>栈的生长方向：向低地址方向生长</p>
<p>堆的生长方向：向高地址方向生长</p>
<h5 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h5><p>EIP：保存着下一条要执行的指令的地址</p>
<h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><p>存放段的基地址，段是一块预分配的内存区域。有些段存放有程序的指令， 有些则存放有程序的变量，另外还有其他的段，如堆栈段存放着函数变量和函数参数等。<br>在 16 位 CPU 中，段寄存器只有 4 个，分别是 CS（代码段）、DS（数据段）、SS（堆栈段）和 ES（附加数据段）。 在 32 位的 CPU 中，<br>段寄存器从 4 个扩展为 6 个，分别是 CS、DS、SS、ES、FS 和 GS。 FS 和 GS 段寄存器也属于附加的段寄存器。</p>
<h5 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h5><p><img src="/images/3.png"></p>
<p>OF（OverFlow Flag）：溢出标志位，用来反映有符号数加减法运算所得结果是否溢出。 如果运算超过当前运算位数所能表示的范围，则称为溢出，该标志位被置为 1，否则为 0； </p>
<p>SF（Sign Flag）：符号标志位，用来反映运算结果的符号位。运算结果为负时为 1， 否则为 0。 ； </p>
<p>ZF（Zero Flag）：零标志位，用来反映运算结果是否为 0。运算结果为 0 时该标志位 被置为 1，否则为 0； </p>
<p>AF（Auxiliary carry Flag）：辅助进位标志位。在字操作时，发生低字节向高字节进位 或借位时该标志位被置为 1，否则为 0（注意：在字节操作时，发生低 4 位向高 4 为进位或借 位时该标志位被置为 1，否则为 0）；</p>
<p>PF（Parity Flag）：奇偶标志位，用于反映结果中“1”的个数的奇偶性。如果“1” 的个数为偶数，该标志位被置为 1，否则为 0。</p>
<p>CF（Carry Flag）：进位标志位。运算结果的最高位产生了一个进位或借位，则该标 志位被置为 1，否则为 0；</p>
<h5 id="常用汇编指令集"><a href="#常用汇编指令集" class="headerlink" title="常用汇编指令集"></a>常用汇编指令集</h5><h6 id="数据传递指令"><a href="#数据传递指令" class="headerlink" title="数据传递指令"></a>数据传递指令</h6><blockquote>
<p>mov 目的操作数，源操作数</p>
</blockquote>
<p>mov 指令是最常见的数据传送指令，它的功能等同于高级语言中的赋值语句。</p>
<p>内存与内存之间是无法直接传递数据的，目的操作数不能为立即数，两个操作数的宽度必须一致。</p>
<p>mov eax, 12345678h </p>
<p>mov eax, dword ptr [00401000h] </p>
<p>mov eax, ebx </p>
<p>mov word ptr [00401000h], 1234h </p>
<p>mov byte ptr [00401000h], al</p>
<blockquote>
<p>xchg 目的操作数, 源操作数</p>
</blockquote>
<p>xchg 指令的功能是交换两个操作数的数据。该指令有两个参数，分别是源操作数和目的操作数。</p>
<p>xchg 指令允许寄存器和寄存器之间交换数据，也允许寄存器和内存之间交换数据，但是内存和内存之间是不能进行数据交换的。</p>
<p>XCHG EAX,EBX  </p>
<p>XCHG DWORD PTR DS:[403020],EBX  </p>
<p>XCHG WORD PTR DS:[403024],CX </p>
<blockquote>
<p>Lea 目的操作数，源操作数</p>
<p>lea r32, mem</p>
</blockquote>
<p>lea 指令是将 mem 的地址装入到一个 32 位的寄存器当中。</p>
<h6 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h6><blockquote>
<p>常用的逻辑运算有 and（与）、or（或）、xor（异或）和 not（非）。</p>
<p>and&#x2F;xor&#x2F;not 目的操作数，源操作数</p>
<p>not 目的操作数</p>
</blockquote>
<p>and&#x2F;xor&#x2F;not 指令影响的标志位有 OF、SF、ZF、PF 和 CF。</p>
<p>结果存到目的操作数中</p>
<h6 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h6><p>add  目的操作数，源操作数   &#x2F;&#x2F; 目的操作数 &#x3D; 目的操作数 + 源操作数 </p>
<p>sub  目的操作数，源操作数   &#x2F;&#x2F; 目的操作数 &#x3D; 目的操作数 - 源操作数 </p>
<p>adc  目的操作数，源操作数   &#x2F;&#x2F; 目的操作数 &#x3D; 目的操作数 + 源操作数 + CF位的值</p>
<p>sbb  目的操作数，源操作数   &#x2F;&#x2F; 目的操作数 &#x3D; 目的操作数 - 源操作数 - CF位的值 </p>
<p>inc  目的操作数   &#x2F;&#x2F; 目的操作数 &#x3D; 目的操作数 + 1</p>
<p>dec  目的操作数  &#x2F;&#x2F; 目的操作数 &#x3D; 目的操作数 - 1</p>
<h6 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h6><blockquote>
<p>堆栈数据操作指令</p>
<p>push reg&#x2F;mem&#x2F;imm </p>
<p>pop reg&#x2F;mem</p>
</blockquote>
<blockquote>
<p>保存&#x2F;恢复通用寄存器现场</p>
<p>Pushad </p>
<p>Popad</p>
</blockquote>
<p>pushad 指令在堆栈上按 顺序压入所有的 32 位通用寄存器，顺序依次是 EAX、ECX、EDX、EBX、ESP、EBP、ESI 和 EDI</p>
<p>popad 指令以相反的顺序从堆栈中弹出这些通用寄存器</p>
<h6 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h6><blockquote>
<p>Jmp reg&#x2F;mem&#x2F;imm</p>
</blockquote>
<p>无条件跳转指令，直接改变EIP的值</p>
<blockquote>
<p>条件转移指令</p>
</blockquote>
<p><img src="/images/4.png"></p>
<p>cmp指令</p>
<blockquote>
<p>Cmp reg, imm&#x2F;reg&#x2F;mem </p>
<p>Cmp mem, imm&#x2F;reg</p>
</blockquote>
<p>比较两个数是否相等</p>
<blockquote>
<p>call reg&#x2F;mem&#x2F;imm</p>
</blockquote>
<p>call 指令是调用过程（函数）的指令，它的作用类似于 jmp 指令，可以修改 EIP 寄存器的值，从而使指令转移到其他地址继续执行。</p>
<p>与 jmp 指令不同的地方是，call 指令在修改 EIP 寄存器的值之前，会将 call 指令的下一条指令的地址保存至堆栈，以便在调用过程（函数） 后再继续从 call 指令处执行</p>
<p>循环指令</p>
<blockquote>
<p>LOOP 00401010</p>
</blockquote>
<p>当ecx寄存器中的值大于0时，EIP跳转到00401010，跳转后ecx减一</p>
<h6 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h6><p>MOV EAX, DWORD PTR [00403000]  直接寻址</p>
<p>MOV EDX, [EAX]  间接寻址</p>
<h3 id="OD工具"><a href="#OD工具" class="headerlink" title="OD工具"></a>OD工具</h3><p>分为反汇编窗口，寄存器窗口，数据窗口，栈窗口，信息窗口</p>
<p>F2  在选中处添加断点</p>
<p>F4 运行到选中处</p>
<p>F8  单步步过，每按一次这个键执行一条反汇编窗口中的一条指令，遇到 CALL 等子程序不进入其代码。</p>
<p>F7：单步步入，功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。</p>
<p>软件断点，硬件断点</p>
<h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h3><ul>
<li><p>PE：Portable Executable File Format（可移植的执行体）。</p>
</li>
<li><p>.exe与.dll文件都是PE格式。</p>
</li>
<li><p>虚拟内存地址 ( VA ) VA &#x3D; 进程的基地址 + RVA</p>
</li>
<li><p>相对虚拟内存地址 ( RVA )</p>
</li>
<li><p>文件偏移地址 ( FOA )</p>
</li>
</ul>
<h5 id="虚拟内存地址与相对虚拟内存地址"><a href="#虚拟内存地址与相对虚拟内存地址" class="headerlink" title="虚拟内存地址与相对虚拟内存地址"></a>虚拟内存地址与相对虚拟内存地址</h5><p>用户的 PE 文件被操作系统加载进内存后， PE 对应的进程支配了自己独立的 4GB 虚拟空间。</p>
<p>在这个空间中定位的地址称为虚拟内存地址 (Virtual Address ，VA )</p>
<p> 进程本身的 VA &#x3D;进程的基地址 + 相对 虚拟内存地址 。</p>
<p>相对虚拟内存地址 (Relative Virtual Address ，RVA ) 是相对于基地址的偏移RVA 是某个特定位置距离某个模块基地址的偏移量<img src="images/5.png" style="zoom:50%;" /></p>
<h5 id="文件偏移地址"><a href="#文件偏移地址" class="headerlink" title="文件偏移地址"></a>文件偏移地址</h5><p>文件偏移地址 (File OffsetAddress ，FOA )  和内存无关 ，它是指某个位置距离文件头的偏移。</p>
<p>静态的，硬盘上的PE文件。</p>
<p>虚拟地址是动态的，内存的，两者有区别。</p>
<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><p>PE 数据结构 中的指针的定义:如果数据结构中某个 字段存储的值为一个地址，那么这个字段就是一个指针。BookStore.Address 是一个指针， Book.Address 也是一个指针 。有时候，你还会遇到 一个指针指向了 另一个指针 的情况。</p>
<h5 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h5><p>Windows 下的可执行文件是 PE 中的一种，这种文件中除了包含代码及数据段的相关数据 以外，还包含许多与文件执行有关的其他数据，比如引用外部函数的信息、 PE 程序的图标、 内部导出函数等，这些数据可能会随着操作系统新特性的出现而增加。</p>
<p>PE 中有一个数据结构称为 数据目录 ，其中记录了所有可能的数据类型。</p>
<p>目前已定义的有 15 种，包括导出表 、导入表、资源表、 异常表、属性证书表 、重定位表等。</p>
<h5 id="节"><a href="#节" class="headerlink" title="节"></a>节</h5><p>节就是存放不同类型数据(比如代码、数据、常量、资源等)的地方，不同的节具有不同的访问权限。节是 PE 文件中存放代码或数据的基本单元 。</p>
<p>比如”.data”   声明的是初始化的数据， “.data?” 声明的是未初始化的数据， “.code”  声明的是可执行的代码等</p>
<h5 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h5><p>由于 Windows 操作系统对内 存属性的设置以页为单位.</p>
<p>节在内存中的对齐单位必须至少是一个页的大小。</p>
<p>32 位的 Windows 系统来说，这个值是 4KB ( 1000h）</p>
<p>64 位操作系统来说，这个值就是 8KB (2000h )。</p>
<h5 id="文件对齐"><a href="#文件对齐" class="headerlink" title="文件对齐"></a>文件对齐</h5><p>通常会以一个物理扇区的大小 作为对齐粒度的值，即 512 字节，十六进制表示为 200h 。</p>
<p>出于节约资源的考虑，操作系统允许节在内存和文件中的对齐尺寸不 一致。</p>
<p>造成了 PE 在文件中和在内存中的大小也会不一致 。也就是说， PE 在内存中的尺寸要比在文件中的尺寸大 。</p>
<h5 id="资源对齐"><a href="#资源对齐" class="headerlink" title="资源对齐"></a>资源对齐</h5><p>资源文件中，资源字节码部分一般要求以双字 (4 个字节）方式对齐</p>
<h5 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h5><p>Unicode 是继 ASCII 字符编码后的另一种新型字符编码 。</p>
<p>严格意义上讲， ASCll 码的每个 字符使用 7 位表示， Unicode 则使用全16 位表示一个字符。</p>
<p>Unicode 字符串中的每个字符均为 双字节 ，所以又称为宽字符串。</p>
<p>由于 Unicode 兼容 ASCII 字符 ，所以被大多数程序所支持，如 Windows 内核。</p>
<p>Unicode 的前 128 个字符码同ASCII 码具有同样字 节值。</p>
<p>字母a: ASCll 编码是 0x61 ;Unicode  编码是 0x0061。</p>
<h5 id="32位系统下的PE结构"><a href="#32位系统下的PE结构" class="headerlink" title="32位系统下的PE结构"></a>32位系统下的PE结构</h5><p><img src="/images/6.png"></p>
<p>因为在 DOS MZ 头中有一个字段 非常重要</p>
<p>IMAGE_DOS_HEADER .e_lfanew ,操作系统定位标准的PE 头部，修改这个值可以去掉DOS头</p>
<img src="images/7.png" style="zoom:80%;" />

<p>程序员眼中的PE结构：</p>
<p><img src="/images/8.png"></p>
<p>标准PE头：</p>
<p><img src="/images/12.png"></p>
<p><img src="/images/11.png"></p>
<p>尽管从名字上看好像该部分数据是可选(optional ) 的，但在 PE 文件结构中，比标准 PE 头更多的内容，让人感觉似乎包才是真正的 PE 头。</p>
<p><img src="/images/9.png"></p>
<p><img src="/images/10.png"></p>
<p>IMAGE_OPTIONAL_HEADER32   (扩展PE 头〉结构 的最后一个字段为 DataDirectory 。是一个IMAGE_DATA_DIRECTORY结构数组，有16个这样的元素。</p>
<p><img src="/images/13.png"></p>
<p>16个结构数组分别表示</p>
<p><img src="/images/14.png"></p>
<p><img src="/images/15.png"></p>
<p>节表结构：</p>
<p><img src="/images/16.png"></p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入表结构：</p>
<p><img src="/images/17.png"></p>
<p><img src="/images/18.png"></p>
<p>当 PE 被加载进虚拟地址 空间以后， IAT 的内容会被操作系统更改为函数的 VA 。这个修改最终会导致通向“值一名称”描述的桥 2 发生断裂。</p>
<p><img src="/images/19.png"></p>
<p>桥 1 指向的地址列表被定义为 INT (Import Name Table)。</p>
<p>桥 2 指向的地址列表被定义为 IAT (lmport Address Table) 。</p>
<h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>导出表结构：</p>
<p><img src="/images/20.png"></p>
<p>目录：</p>
<p><img src="/images/21.png"></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>内存中的栈结构：</p>
<p><img src="/images/22.png"></p>
<p>在对栈进行操作时，一定要维系栈平衡，即压入多少字节最后就要弹出多少字节， 否则会导致程序运行出现错误</p>
<p>将调用函数用到的参数入栈。将call指令的下一条指令入栈，以备返回。保存原始 ebp指针函数准备栈空间，ebp指向栈中该函数的基地址。为函数中定义的局部变量开辟栈空间（通过调整 esp来完成）运行函数中定义的语句。清理局部变量，恢复原始的ebp指 针-leave返回步骤 2 保存的下一条指令处执行，同时清理栈中的函数参数（通过指令retn 8 完成，为什么是8？）答：之前压了2个参数，弹出EIP后，要将EXP再加8，将栈指针恢复到调用函数之前</p>
<p><img src="/images/23.png"></p>
<p>在函数中，利用ebp+n读取参数，ebp-n读取局部变量</p>
<p>栈溢出原理：将edi记录为ebp-4（即第一个局部变量），将其循环修改值，将局部变量填充满，再将原EBP填充满，最后将EIP修改</p>
]]></content>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
</search>
